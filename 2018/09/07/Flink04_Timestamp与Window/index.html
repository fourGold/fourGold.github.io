<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Flink04_Timestamp与window的实战与源码分析, 觉浅">
    <meta name="description" content="Jinxin Li的个人博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Flink04_Timestamp与window的实战与源码分析 | 觉浅</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">觉浅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">觉浅</div>
        <div class="logo-desc">
            
            Jinxin Li的个人博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="http://github.com/fourgold/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="http://github.com/fourgold/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/10.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Flink04_Timestamp与window的实战与源码分析</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2018-09-07
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.5k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">Table table &#x3D; input
  .window([GroupWindow w].as(&quot;w&quot;))  &#x2F;&#x2F; define window with alias w
  .groupBy(&quot;w, a&quot;)  &#x2F;&#x2F; group the table by attribute a and window w 
  .select(&quot;a, w.start, w.end, w.rowtime, b.count&quot;); &#x2F;&#x2F; aggregate and add window start, end, and rowtime timestamps</code></pre>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">&#x2F;&#x2F;Tumble ----------
&#x2F;&#x2F; Tumbling Event-time Window
.window(Tumble.over(&quot;10.minutes&quot;).on(&quot;rowtime&quot;).as(&quot;w&quot;));

&#x2F;&#x2F; Tumbling Processing-time Window (assuming a processing-time attribute &quot;proctime&quot;)
.window(Tumble.over(&quot;10.minutes&quot;).on(&quot;proctime&quot;).as(&quot;w&quot;));

&#x2F;&#x2F; Tumbling Row-count Window (assuming a processing-time attribute &quot;proctime&quot;)
.window(Tumble.over(&quot;10.rows&quot;).on(&quot;proctime&quot;).as(&quot;w&quot;));    </code></pre>
<h1 id="0x1-Windows概述"><a href="#0x1-Windows概述" class="headerlink" title="0x1.Windows概述"></a>0x1.Windows概述</h1><p>Streaming流式计算是一种被设计用于处理无限数据集的数据处理引擎，而无限数据集是指一种不断增长的本质上无限的数据集，而window是一种<strong>切割无限数据为有限块进行处理</strong>的手段。</p>
<p>Window是无限数据流处理的核心，Window将一个无限的stream拆分成有限大小的”buckets”桶，我们可以在这些桶上做计算操作</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @author JueQian
 * @create 01-12 11:59
 * 概述:
 * 窗口类型分两种:时间窗口 计数窗口
 * 窗口功能分三种:滚动 滑动 会话(时间窗口特有)
 * 窗口方法分两种:增量(aggregate:sum,min,max)全量(apply)
 *&#x2F;
public class Flink01_TimeWindow &#123;
    public static void main(String[] args) throws Exception &#123;
        &#x2F;&#x2F;0x0 获取执行环境
        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(2);

        &#x2F;&#x2F;0x1 从执行环境中获取
        DataStreamSource&lt;SensorReading&gt; sensorSource &#x3D; env.addSource(new Flink05_Source_UDFSource.MySource());

        &#x2F;&#x2F;0x2 使用时间窗口统计每个窗口的最高温度
        WindowedStream&lt;SensorReading, String, TimeWindow&gt; windowStream &#x3D; sensorSource.keyBy(SensorReading::getId).timeWindow(Time.seconds(5));

        SingleOutputStreamOperator&lt;SensorReading&gt; temp &#x3D; windowStream.maxBy(&quot;temp&quot;);

        &#x2F;&#x2F;0x3 打印
        temp.print(&quot;最高温度&quot;);

        &#x2F;&#x2F;0x4 执行
        env.execute();
    &#125;
&#125;</code></pre>
<p>窗口函数分两种</p>
<pre class="mermaid">graph LR
A[窗口函数]-->B[增量窗口函数]
A-->C[全量窗口函数]</pre>

<p>Window可以分成两类：</p>
<p>CountWindow：按照指定的数据条数生成一个Window，与时间无关。</p>
<p>TimeWindow：按照时间生成Window。</p>
<p><strong>注意</strong></p>
<p>CountWindow没有Session,比如隔着几条没有来数据???显然不符合逻辑</p>
<pre class="mermaid">graph LR
A[window]-->B[CountWindow]
A-->C[TimeWindow]
C-->D[Tumbing Window]
C-->E[Sliding window]
C-->F[Session Window]
B-->G[Tumbing Window]
B-->H[Sliding window]</pre>

<h2 id="1-TimeWindow"><a href="#1-TimeWindow" class="headerlink" title="1.TimeWindow"></a>1.TimeWindow</h2><p>对于TimeWindow，可以根据窗口实现原理的不同分成三类：滚动窗口（Tumbling Window）、滑动窗口（Sliding Window）和会话窗口（Session Window）。</p>
<h3 id="1-滚动窗口（Tumbling-Windows）"><a href="#1-滚动窗口（Tumbling-Windows）" class="headerlink" title="1.滚动窗口（Tumbling Windows）"></a>1.滚动窗口（Tumbling Windows）</h3><p>将数据依据固定的窗口长度对数据进行切片。</p>
<p><strong>特点：时间对齐，窗口长度固定，没有重叠。</strong></p>
<p>滚动窗口分配器将每个元素分配到一个指定窗口大小的窗口中，滚动窗口有一个固定的大小，并且不会出现重叠。例如：如果你指定了一个5分钟大小的滚动窗口，窗口的创建如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="滚动窗口示意图"></p>
<p>适用场景：适合做BI统计等（做每个时间段的聚合计算）。</p>
<h3 id="2-滑动窗口（Sliding-Windows）"><a href="#2-滑动窗口（Sliding-Windows）" class="headerlink" title="2.滑动窗口（Sliding Windows）"></a>2.滑动窗口（Sliding Windows）</h3><p>滑动窗口是固定窗口的更广义的一种形式，滑动窗口由固定的窗口长度和滑动间隔组成。</p>
<p><strong>特点：时间对齐，窗口长度固定，可以有重叠。</strong></p>
<p>滑动窗口分配器将元素分配到固定长度的窗口中，与滚动窗口类似，窗口的大小由窗口大小参数来配置，另一个窗口滑动参数控制滑动窗口开始的频率。</p>
<p>因此，滑动窗口如果滑动参数小于窗口大小的话，窗口是可以重叠的，在这种情况下元素会被分配到多个窗口中。</p>
<p>例如，你有10分钟的窗口和5分钟的滑动，那么每个窗口中5分钟的窗口里包含着上个10分钟产生的数据，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="滑动窗口示意图"></p>
<p>适用场景：对最近一个时间段内的统计（求某接口最近5min的失败率来决定是否要报警)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E6%97%B6%E9%97%B4%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B0%8F%E5%9D%97%E5%BD%92%E5%B1%9E%E9%97%AE%E9%A2%98.png" alt="image-20210112170315668"></p>
<h3 id="3-会话窗口（Session-Windows）"><a href="#3-会话窗口（Session-Windows）" class="headerlink" title="3. 会话窗口（Session Windows）"></a>3. 会话窗口（Session Windows）</h3><p>由一系列事件组合一个指定时间长度的timeout间隙组成，类似于web应用的session，也就是一段时间没有接收到新数据就会生成新的窗口。</p>
<p><strong>特点：时间无对齐。</strong></p>
<p>session窗口分配器通过session活动来对元素进行分组，session窗口跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况，相反，当它在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭。</p>
<p>一个session窗口通过一个session间隔来配置，这个session间隔定义了非活跃周期的长度，当这个非活跃周期产生，那么当前的session将关闭并且后续的元素将被分配到新的session窗口中去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E4%BC%9A%E8%AF%9D%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="时间回话窗口"></p>
<h2 id="2-CountWindow"><a href="#2-CountWindow" class="headerlink" title="2.CountWindow"></a>2.CountWindow</h2><p>CountWindow根据窗口中相同key元素的数量来触发执行，执行时只计算元素数量达到窗口大小的key对应的结果。</p>
<p>注意：CountWindow的window_size指的是相同Key的元素的个数，不是输入的所有元素的总数。</p>
<h3 id="1-滚动窗口"><a href="#1-滚动窗口" class="headerlink" title="1.滚动窗口"></a>1.滚动窗口</h3><p>默认的CountWindow是一个滚动窗口，只需要指定窗口大小即可，当元素数量达到窗口大小时，就会触发窗口的执行。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DataStream&lt;SensorReading&gt; minTempPerWindowStream &#x3D; 
    dataStream
    .keyBy(SensorReading::getId)
    .countWindow(5)
    .minBy(&quot;temperature&quot;);</code></pre>
<h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h3><p>滑动窗口和滚动窗口的函数名是完全一致的，只是在传参数时需要传入两个参数，一个是window_size，一个是sliding_size。</p>
<p>下面代码中的sliding_size设置为了2，也就是说，每收到两个相同key的数据就计算一次，每一次计算的window范围是10个元素。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DataStream&lt;SensorReading&gt; minTempPerWindowStream &#x3D; 
    dataStream
    .keyBy(SensorReading::getId)
    .countWindow(10,2)
    .minBy(&quot;temperature&quot;);</code></pre>
<h3 id="3-WindowFunction"><a href="#3-WindowFunction" class="headerlink" title="3.WindowFunction"></a>3.WindowFunction</h3><p>window function 定义了要对窗口中收集的数据做的计算操作，主要可以分为两类：</p>
<p>增量聚合函数（incremental aggregation functions）</p>
<p>每条数据到来就进行计算，保持一个简单的状态。典型的增量聚合函数有<strong>ReduceFunction</strong>, <strong>AggregateFunction</strong>。</p>
<p>全窗口函数（full window functions）</p>
<p>先把窗口所有数据收集起来，等到计算的时候会遍历所有数据。ProcessWindowFunction就是一个全窗口函数。</p>
<h2 id="4-功能API"><a href="#4-功能API" class="headerlink" title="4.功能API"></a>4.功能API</h2><h3 id="KeyedWindows"><a href="#KeyedWindows" class="headerlink" title="KeyedWindows"></a>KeyedWindows</h3><p>1.trigger() —— 触发器</p>
<p>定义 window 什么时候关闭，触发计算并输出结果</p>
<p>2.evitor() —— 移除器</p>
<p>定义移除某些数据的逻辑</p>
<p>3.allowedLateness() —— 允许处理迟到的数据</p>
<p>4.sideOutputLateData() —— 将迟到的数据放入侧输出流</p>
<p>5.getSideOutput() —— 获取侧输出流</p>
<h3 id="Non-KeyedWindows"><a href="#Non-KeyedWindows" class="headerlink" title="Non_KeyedWindows"></a>Non_KeyedWindows</h3><p>WindowAll()</p>
<p>trigger()</p>
<p>evictor()</p>
<p>allowedLateness()</p>
<p>sideOutoutLateData()</p>
<p>getSideOutput</p>
<h1 id="0x2-时间语义与Watermark"><a href="#0x2-时间语义与Watermark" class="headerlink" title="0x2.时间语义与Watermark"></a>0x2.时间语义与Watermark</h1><h2 id="1-Flink中的时间语义"><a href="#1-Flink中的时间语义" class="headerlink" title="1.Flink中的时间语义"></a>1.Flink中的时间语义</h2><p>在Flink的流式处理中，会涉及到时间的不同概念，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/Flink%E7%9A%84%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89.png" alt="Flink的时间语义"></p>
<p><strong>Event Time</strong>:日志自己记录的时间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment
    .getExecutionEnvironment
    &#x2F;&#x2F; 从调用时刻开始给env创建的每一个stream追加时间特性
    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
    &#x2F;&#x2F;在后续指定时间时间语义</code></pre>
<p><strong>Ingestion Time</strong>:是数据进入Flink的时间</p>
<p><strong>Processing Time</strong>:是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是Processing Time。</p>
<h2 id="2-乱序数据的产生"><a href="#2-乱序数据的产生" class="headerlink" title="2.乱序数据的产生"></a>2.乱序数据的产生</h2><p>原因:由于网络、分布式等原因，导致乱序的产生,接受数据时间不按照实际时间</p>
<p>测试Kafka</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">2&gt; sensor_0:2021-01-13 12:56:34
2&gt; sensor_0:2021-01-13 12:56:36
2&gt; sensor_0:2021-01-13 12:56:38
2&gt; sensor_0:2021-01-13 12:56:40
2&gt; sensor_0:2021-01-13 12:56:42
1&gt; sensor_0:2021-01-13 15:52:53&#x2F;&#x2F;跑到12.56.44前面
2&gt; sensor_0:2021-01-13 12:56:44
2&gt; sensor_0:2021-01-13 12:56:46
2&gt; sensor_0:2021-01-13 12:56:48
1&gt; sensor_0:2021-01-13 15:52:55
2&gt; sensor_0:2021-01-13 12:56:50
2&gt; sensor_0:2021-01-13 12:56:52
1&gt; sensor_0:2021-01-13 15:52:57
2&gt; sensor_0:2021-01-13 12:56:54
1&gt; sensor_0:2021-01-13 15:52:59
2&gt; sensor_0:2021-01-13 12:56:56
1&gt; sensor_0:2021-01-13 15:53:01</code></pre>
<h2 id="3-waterMark的引入"><a href="#3-waterMark的引入" class="headerlink" title="3.waterMark的引入"></a>3.waterMark的引入</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;0x0 要求使用时间语义
StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment
    .getExecutionEnvironment
    &#x2F;&#x2F;从调用时刻开始给env创建的每一个stream追加时间特性
    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
    &#x2F;&#x2F;在后续指定时间时间语义
    
&#x2F;&#x2F;0x1 要求指定时间语义
dataStream.assignTimestampsAndWatermarks(
    new BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;
    (Time.milliseconds(1000)) &#123;
        @Override
        public long extractTimestamp(element: SensorReading): Long &#x3D; &#123;
            return element.getTimestamp() * 1000L;
        &#125;
    &#125;);</code></pre>
<p>翻译成水印水位线</p>
<p>WaterMark用于关闭窗口</p>
<p><strong>重点</strong></p>
<p>Watermark本质是一个插入到流中的时间戳,规定了窗口关闭的时间.</p>
<p>在00:00开始5min窗口</p>
<p>定义Watermark+1min</p>
<p>则窗口关闭时间为00:06</p>
<p>在这延迟的一分钟内,如果到达时间依然在0-5min之内,依然可以进入窗口</p>
<p>(目的是为了让延迟数据也能进入窗口,因为比timestamp要小)</p>
<p><strong>说白了</strong></p>
<p>窗口:存储规定时间段内发生的事件</p>
<p>WaterMark:让时间字段发生在窗口内,但是迟到了的数据进入窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/WaterMark%E4%B8%8E%E7%AA%97%E5%8F%A3.png" alt="WaterMark与窗口"></p>
<h1 id="0x3-Window的源码解析"><a href="#0x3-Window的源码解析" class="headerlink" title="0x3.Window的源码解析"></a>0x3.Window的源码解析</h1><h2 id="1-格林威治时间"><a href="#1-格林威治时间" class="headerlink" title="1.格林威治时间"></a>1.格林威治时间</h2><p>点击</p>
<p>timewindow-&gt;of</p>
<p>滑动窗口代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static TumblingProcessingTimeWindows of(Time size) &#123;
        return new TumblingProcessingTimeWindows(size.toMilliseconds(), 0L);
    &#125;</code></pre>
<p>如果开一天窗口</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;0x3 分组
      KeyedStream&lt;SensorReading, String&gt; one2Sensor &#x3D; sensorWithTime.keyBy(SensorReading::getId);

      &#x2F;&#x2F;0x4 开窗
      SingleOutputStreamOperator&lt;SensorReading&gt; result &#x3D; one2Sensor.timeWindow(Time.seconds(5)).min(&quot;temp&quot;);

      &#x2F;&#x2F;由于是UTC格林兰治的时间
      one2Sensor.timeWindow(Time.days(1));&#x2F;&#x2F;这个window是早八点到八点
      &#x2F;&#x2F;如果国内想开一天的窗口
  one2Sensor.window(TumblingProcessingTimeWindows.of(Time.days(1),Time.hours(-8)));</code></pre>
<h2 id="2-关于窗口整点问题"><a href="#2-关于窗口整点问题" class="headerlink" title="2.关于窗口整点问题"></a>2.关于窗口整点问题</h2><p>左闭右开</p>
<p>窗口是一个桶</p>
<h3 id="2-1窗口整数问题源码处理"><a href="#2-1窗口整数问题源码处理" class="headerlink" title="2.1窗口整数问题源码处理"></a>2.1窗口整数问题源码处理</h3><p><strong>源码</strong></p>
<p>timewindow-&gt;TumblingProcessingTimeWindows-&gt;assignWindows-&gt;getWindowStartWithOffset</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;&#x2F;计算第一个窗口的开始时间
public static long getWindowStartWithOffset(long timestamp, long offset, long windowSize) &#123;
        return timestamp - (timestamp - offset + windowSize) % windowSize;
    &#125;</code></pre>
<p>参数解析:</p>
<p>offset=0 (关于东八区偏移时间)</p>
<p>timestamp=0(关于时间戳)</p>
<p>windowSize保证时间为正数</p>
<p>计算,假如我们在20:36输入15min的 滚动窗口</p>
<p>可以将上述公式简化为下面公式<br>$$<br>timestamp - timestamp/windowSize<br>$$<br>举例:</p>
<p>10-10/6 = 6</p>
<p>先使用时间戳对窗口大小取余</p>
<p>然后减去这个余数,为第一个窗口开始时间</p>
<h3 id="2-2左闭右开源码-end-1"><a href="#2-2左闭右开源码-end-1" class="headerlink" title="2.2左闭右开源码(end-1)"></a>2.2左闭右开源码(end-1)</h3><p>timewindow.java-&gt;end</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当前窗口所属的最大时间
@Override
	public long maxTimestamp() &#123;
		return end - 1;
	&#125;</code></pre>
<h3 id="2-3滑动窗口属于多个窗口源码解析"><a href="#2-3滑动窗口属于多个窗口源码解析" class="headerlink" title="2.3滑动窗口属于多个窗口源码解析"></a>2.3滑动窗口属于多个窗口源码解析</h3><p>timeWindow-&gt;SlidingProcessingTimeWindows.class-&gt;assignWindows</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;
        timestamp &#x3D; context.getCurrentProcessingTime();
        List&lt;TimeWindow&gt; windows &#x3D; 
            new ArrayList((int)(this.size &#x2F; this.slide));&#x2F;&#x2F;一下子计算出将数据属于的窗口
        long lastStart &#x3D; TimeWindow
            .getWindowStartWithOffset(
            	timestamp, 
            	this.offset, 
            	this.slide);&#x2F;&#x2F;windowsize是把滑动步长当做slide
        for(long start &#x3D; lastStart; &#x2F;&#x2F;遍历
            start &gt; timestamp - this.size; 
            start -&#x3D; this.slide) &#123;&#x2F;&#x2F;进去slide
            windows.add(new TimeWindow(start, start + this.size));
        &#125;
        return windows;
    &#125;</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;getWindowStartWithOffset
public static long getWindowStartWithOffset(long timestamp, long offset, long windowSize) &#123;
		return timestamp - (timestamp - offset + windowSize) % windowSize;
	&#125;</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%BA%90%E7%A0%81.png" alt="滑动窗口源码"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="滑动窗口源码示意图"></p>
<p><strong>总结</strong></p>
<p>一个窗口15秒,滑动步长为5秒,此时存在三个滑动小窗口</p>
<p>源码内是吧滑动的一步当做一个滚动窗口进行计算,</p>
<p>然后把滚动计算放置到一个ArrayList中,统计计算</p>
<p>源码是当一个15秒窗口,先计算出最后的一个小窗口,往前推</p>
<h1 id="0x4-深入了解WaterMark使用与源码"><a href="#0x4-深入了解WaterMark使用与源码" class="headerlink" title="0x4.==深入了解WaterMark使用与源码=="></a>0x4.==深入了解WaterMark使用与源码==</h1><p>问题还没解决!!!!</p>
<p>简单解析</p>
<p>waterMark的时间戳本质:延长窗口关闭时间</p>
<p>[window:0-5]</p>
<p>[watermark:2]</p>
<p>接受数据[0-5]</p>
<p>关闭时间[7]</p>
<h2 id="1-WaterMark使用Example"><a href="#1-WaterMark使用Example" class="headerlink" title="1.WaterMark使用Example"></a>1.WaterMark使用Example</h2><p>数据案例 求5秒内,2秒watermark,2秒网络延迟条件下的最大延迟时间</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">sensor_1,1610506280,10
sensor_1,1610506281,20
sensor_1,1610506282,30
sensor_1,1610506283,40
sensor_1,1610506284,50
sensor_1,1610506285,60
sensor_1,1610506286,70
sensor_1,1610506287,80
sensor_1,1610506288,90
sensor_1,1610506290,100</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ecust.watermark;

import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple;
import org.apache.flink.api.java.tuple.Tuple3;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.datastream.WindowedStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.OutputTag;

&#x2F;**
 * @author JueQian
 * @create 01-13 11:43
 * 延迟发车 waterMark 包容数据的混乱度
 * 允许迟到时间发车等人 allowedLateness 允许迟到数据,包容网络的延迟
 * 侧输出流 sideOutputStream 保证数据的准确一致性(牺牲了一点准确性,保证了高效性)
 * todo 测输出流不参与计算,需要统计然后单独处理
 *&#x2F;
public class Flink02_Window_WaterMark_Lateness &#123;
    public static void main(String[] args) throws Exception &#123;

        &#x2F;&#x2F;0x0 定义执行环境,并且从端口读取数据
        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        DataStreamSource&lt;String&gt; socketSource &#x3D; env.socketTextStream(&quot;hadoop102&quot;, 9999);

        &#x2F;&#x2F;0x1 将数据添加上数据结构
        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Double&gt;&gt; mapStream &#x3D; socketSource.map(new MapFunction&lt;String, Tuple3&lt;String, Long, Double&gt;&gt;() &#123;
            @Override
            public Tuple3&lt;String, Long, Double&gt; map(String s) throws Exception &#123;
                String[] fields &#x3D; s.split(&quot;,&quot;);
                return new Tuple3&lt;&gt;(fields[0], Long.parseLong(fields[1])*1000, Double.parseDouble(fields[2]));
            &#125;
        &#125;);

        &#x2F;&#x2F;0x2 指定时间语义 设定waterMark为两秒
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Double&gt;&gt; watermarks &#x3D; mapStream.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;Tuple3&lt;String, Long, Double&gt;&gt;(Time.seconds(2)) &#123;
            @Override
            public long extractTimestamp(Tuple3&lt;String, Long, Double&gt; stringLongDoubleTuple3) &#123;
                return stringLongDoubleTuple3.f1;
            &#125;
        &#125;);

        &#x2F;&#x2F;0x3 开窗,设定窗口时间与测输出流
        WindowedStream&lt;Tuple3&lt;String, Long, Double&gt;, Tuple, TimeWindow&gt; timeWindow &#x3D; watermarks.keyBy(1).timeWindow(Time.seconds(5));
        WindowedStream&lt;Tuple3&lt;String, Long, Double&gt;, Tuple, TimeWindow&gt; windowedStream &#x3D; timeWindow
                .allowedLateness(Time.seconds(2))
                .sideOutputLateData(new OutputTag&lt;Tuple3&lt;String, Long, Double&gt;&gt;(&quot;side&quot;) &#123;&#125;);
                &#x2F;&#x2F;计算窗口时间内的温度的最大值
        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Double&gt;&gt; streamOperator &#x3D; windowedStream.maxBy(2);
        &#x2F;&#x2F;0x4 打印
        streamOperator.print(&quot;主输出流&quot;);
        streamOperator.getSideOutput(new OutputTag&lt;Tuple3&lt;String, Long, Double&gt;&gt;(&quot;side&quot;) &#123;&#125;).print(&quot;测输出流&quot;);

        &#x2F;&#x2F;0x5 执行
        env.execute();
    &#125;
&#125;</code></pre>
<h2 id="2-源码解析assignTimestampsAndWatermarks"><a href="#2-源码解析assignTimestampsAndWatermarks" class="headerlink" title="2.源码解析assignTimestampsAndWatermarks"></a>2.源码解析assignTimestampsAndWatermarks</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">assignTimestampsAndWatermarks-&gt;
    AssignerWithPeriodicWatermarks-&gt;
    ctrl+H-&gt;</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/%E5%91%A8%E6%9C%9F%E6%80%A7waterMark%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="周期性waterMark继承关系图"></p>
<p>自增时间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">AscendingTimestampExtractor()&#x2F;&#x2F;自增</code></pre>
<p>使用自己的时间 ,时间自增</p>
<p><strong>源码:</strong></p>
<p>waterMark是一个衡量时间进展机制</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final long extractTimestamp(T element, long elementPrevTimestamp) &#123;
        long newTimestamp &#x3D; this.extractAscendingTimestamp(element);
        if (newTimestamp &gt;&#x3D; this.currentTimestamp) &#123;
            this.currentTimestamp &#x3D; newTimestamp;
            return newTimestamp;
        &#125; else &#123;
            this.violationHandler.handleViolation(newTimestamp, this.currentTimestamp);
            return newTimestamp;
        &#125;
    &#125;

    public final Watermark getCurrentWatermark() &#123;
        return new Watermark(this.currentTimestamp &#x3D;&#x3D; -9223372036854775808L ? -9223372036854775808L : this.currentTimestamp - 1L);
    &#125;</code></pre>
<h2 id="3-WaterMark的传递"><a href="#3-WaterMark的传递" class="headerlink" title="3.WaterMark的传递"></a>3.WaterMark的传递</h2><p> Such an operator’s current event time is the minimum of its input streams’ event times. As its input streams update their event times, so does the operator.</p>
<p>算子的执行时间取输入流中最小的事件时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/WaterMark%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98.png" alt="WaterMark传递机制"></p>
<p>周期性每200ms产生一个新数据</p>
<ol>
<li>watermark是往下游广播的</li>
<li>当所有waterMark中的最小的WaterMark</li>
</ol>
<p><strong>测试</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ecust.watermark;

import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple;
import org.apache.flink.api.java.tuple.Tuple3;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.datastream.WindowedStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.timestamps.AscendingTimestampExtractor;
import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.OutputTag;

&#x2F;**
 * @author JueQian
 * @create 01-13 11:43
 * 测试一下在文件流经常使用的自增时间
 *&#x2F;
public class Flink04_Window_WaterMark_AscendingTimes &#123;
    public static void main(String[] args) throws Exception &#123;

        &#x2F;&#x2F;0x0 定义执行环境,并且从端口读取数据
        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        DataStreamSource&lt;String&gt; socketSource &#x3D; env.socketTextStream(&quot;hadoop102&quot;, 9999);

        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        &#x2F;&#x2F;使用自增时间语义
        SingleOutputStreamOperator&lt;String&gt; assignTimestampsAndWatermarks &#x3D; socketSource.assignTimestampsAndWatermarks(new AscendingTimestampExtractor&lt;String&gt;() &#123;
            @Override
            public long extractAscendingTimestamp(String s) &#123;
                String[] fields &#x3D; s.split(&quot;,&quot;);
                return Long.parseLong(fields[1])*1000L;
            &#125;
        &#125;);

        &#x2F;&#x2F;0x1 将数据添加上数据结构 进行第一个map的时候是进行hash分布
        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Double&gt;&gt; mapStream &#x3D; assignTimestampsAndWatermarks.map(new MapFunction&lt;String, Tuple3&lt;String, Long, Double&gt;&gt;() &#123;
            @Override
            public Tuple3&lt;String, Long, Double&gt; map(String s) throws Exception &#123;
                String[] fields &#x3D; s.split(&quot;,&quot;);
                return new Tuple3&lt;&gt;(fields[0], Long.parseLong(fields[1])*1000, Double.parseDouble(fields[2]));
            &#125;
        &#125;);

        &#x2F;&#x2F;0x3 开窗,设定窗口时间与测输出流
        WindowedStream&lt;Tuple3&lt;String, Long, Double&gt;, Tuple, TimeWindow&gt; timeWindow &#x3D; mapStream.keyBy(1).timeWindow(Time.seconds(5));
        WindowedStream&lt;Tuple3&lt;String, Long, Double&gt;, Tuple, TimeWindow&gt; windowedStream &#x3D; timeWindow
                .allowedLateness(Time.seconds(2))
                .sideOutputLateData(new OutputTag&lt;Tuple3&lt;String, Long, Double&gt;&gt;(&quot;side&quot;) &#123;&#125;);

        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Double&gt;&gt; streamOperator &#x3D; windowedStream.maxBy(2);

        &#x2F;&#x2F;0x4 打印
        streamOperator.print(&quot;主输出流&quot;);
        streamOperator.getSideOutput(new OutputTag&lt;Tuple3&lt;String, Long, Double&gt;&gt;(&quot;side&quot;) &#123;&#125;).print(&quot;测输出流&quot;);

        &#x2F;&#x2F;0x5 执行
        env.execute();
    &#125;
&#125;</code></pre>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#测试数据信息----------------
waterMark &#x3D; 2
window&#x3D;5
#-------------------------
sensor_1,1610506279,5

sensor_1,1610506282,30
sensor_1,1610506283,40
#在282理应生成数据,但是输入283之后才会生成数据</code></pre>
<h3 id="4-AssignerWithPeriodicWatermarks"><a href="#4-AssignerWithPeriodicWatermarks" class="headerlink" title="4.AssignerWithPeriodicWatermarks"></a>4.AssignerWithPeriodicWatermarks</h3><p>会定时抽取waterMark</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;默认200ms
public void setStreamTimeCharacteristic(TimeCharacteristic characteristic) &#123;
    this.timeCharacteristic &#x3D; Preconditions.checkNotNull(characteristic);
    if (characteristic &#x3D;&#x3D; TimeCharacteristic.ProcessingTime) &#123;
        getConfig().setAutoWatermarkInterval(0);
    &#125; else &#123;
        getConfig().setAutoWatermarkInterval(200);
    &#125;
&#125;</code></pre>
<p><strong>触发机制</strong></p>
<p>window的触发要符合以下几个条件：</p>
<ol>
<li>watermark时间 &gt;= window_end_time</li>
<li>在[window_start_time,window_end_time)中有数据存在</li>
</ol>
<p>同时满足了以上2个条件，window才会触发。</p>
<p>watermark是一个全局的值，不是某一个key下的值，所以即使不是同一个key的数据，其warmark也会增加.</p>
<p>WaterMark在数据中表示小于等于WaterMark的数据全部到齐</p>
<h2 id="5-WaterMark源码"><a href="#5-WaterMark源码" class="headerlink" title="5.WaterMark源码"></a>5.WaterMark源码</h2><p><strong>example</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;指定时间语义
SingleOutputStreamOperator&lt;String&gt; assignTimestampsAndWatermarks &#x3D; socketSource.
                assignTimestampsAndWatermarks(
                        new BoundedOutOfOrdernessTimestampExtractor&lt;String&gt;
                                (Time.milliseconds(200)) &#123;
            @Override
            public long extractTimestamp(String s) &#123;
                String[] fields &#x3D; s.split(&quot;,&quot;);
                return Long.parseLong(fields[1]) * 1000L;
            &#125;
        &#125;);</code></pre>


<h3 id="5-1-获取WaterMark的方法类"><a href="#5-1-获取WaterMark的方法类" class="headerlink" title="5.1 获取WaterMark的方法类"></a>5.1 获取WaterMark的方法类</h3><p><strong>点击方式</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">new BoundedOutOfOrdernessTimestampExtractor-&gt;
    getCurrentWatermark()</code></pre>
<p>WaterMark生成机制</p>
<p><strong>BoundedOutOfOrdernessTimestampExtractor源码</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class BoundedOutOfOrdernessTimestampExtractor&lt;T&gt; implements AssignerWithPeriodicWatermarks&lt;T&gt; &#123;

	private static final long serialVersionUID &#x3D; 1L;

	&#x2F;** 目前为止最大的时间戳 *&#x2F;
	private long currentMaxTimestamp;

	&#x2F;** 最近从上游提交的时间戳,默认为Long的最小值*&#x2F;
	private long lastEmittedWatermark &#x3D; Long.MIN_VALUE;

	&#x2F;**最大无序度*&#x2F;
	private final long maxOutOfOrderness;

	public BoundedOutOfOrdernessTimestampExtractor(Time maxOutOfOrderness) &#123;
		if (maxOutOfOrderness.toMilliseconds() &lt; 0) &#123;
			throw new RuntimeException(&quot;Tried to set the maximum allowed &quot; +
				&quot;lateness to &quot; + maxOutOfOrderness + &quot;. This parameter cannot be negative.&quot;);
		&#125;
        &#x2F;&#x2F;给无序度赋值
		this.maxOutOfOrderness &#x3D; maxOutOfOrderness.toMilliseconds();
		this.currentMaxTimestamp &#x3D; Long.MIN_VALUE + this.maxOutOfOrderness;
	&#125;
	
    
    &#x2F;&#x2F;得到最大的无序度,在程序的参数里指定的
	public long getMaxOutOfOrdernessInMillis() &#123;
		return maxOutOfOrderness;
	&#125;

	&#x2F;**
	 * Extracts the timestamp from the given element.
	 *&#x2F;
	public abstract long extractTimestamp(T element);

	@Override
	public final Watermark getCurrentWatermark() &#123;
		&#x2F;&#x2F; this guarantees that the watermark never goes backwards.
        &#x2F;&#x2F; 因为存在乱序数据,所以需要保持时间戳不能倒退
        &#x2F;&#x2F; 保证时间戳不会倒退 一直使用最小的水位线作为真正的水位线
        
        &#x2F;&#x2F;自增原理:只有生成的waterMark,比当前的waterMark大的时候才会进行赋值
		long potentialWM &#x3D; currentMaxTimestamp - maxOutOfOrderness;
		if (potentialWM &gt;&#x3D; lastEmittedWatermark) &#123;
			lastEmittedWatermark &#x3D; potentialWM;
		&#125;
		return new Watermark(lastEmittedWatermark);
	&#125;

	@Override
	public final long extractTimestamp(T element, long previousElementTimestamp) &#123;
		long timestamp &#x3D; extractTimestamp(element);
		if (timestamp &gt; currentMaxTimestamp) &#123;
			currentMaxTimestamp &#x3D; timestamp;
		&#125;
		return timestamp;
	&#125;
&#125;</code></pre>
<h3 id="WaterMark类"><a href="#WaterMark类" class="headerlink" title="WaterMark类"></a><strong>WaterMark类</strong></h3><p><strong>点击方式</strong></p>
<p>直接搜waterMark</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 不缓存元素的算子在他们得到watermark之后会向下游算子发送waterMark
 缓存元素的算子比如window operators,必须waterMark之后往下游发送数据,需要watermark触发计算
 *&#x2F;
@PublicEvolving
public final class Watermark extends StreamElement &#123;

	&#x2F;** The watermark that signifies end-of-event-time. *&#x2F;
	public static final Watermark MAX_WATERMARK &#x3D; new Watermark(Long.MAX_VALUE);

	&#x2F;&#x2F; ------------------------------------------------------------------------

	&#x2F;** The timestamp of the watermark in milliseconds. *&#x2F;
	private final long timestamp;

	&#x2F;**
	 * Creates a new watermark with the given timestamp in milliseconds.
	 *&#x2F;
	public Watermark(long timestamp) &#123;
		this.timestamp &#x3D; timestamp;
	&#125;

	&#x2F;**
	 * Returns the timestamp associated with this &#123;@link Watermark&#125; in milliseconds.
	 *&#x2F;
	public long getTimestamp() &#123;
		return timestamp;
	&#125;
&#125;</code></pre>
<p>RDD中有很多实现类,每一个RDD的实现类里</p>
<p>SparkRDD中都有一个compute方法,我们传入逻辑,改变compute方法,才能进行计算</p>
<p>Flink中所有的map与flatmap都对应一个(StreamOperator的实现类)</p>
<h3 id="WaterMark生成算子"><a href="#WaterMark生成算子" class="headerlink" title="WaterMark生成算子"></a>WaterMark生成算子</h3><p><strong>点击方式</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">map.assignTimestampsAndWatermarks-&gt;
    new TimestampsAndPeriodicWatermarksOperator&lt;&gt;(cleanedAssigner);</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">StreamOperator-&gt;
     TimestampsAndPeriodicWatermarksOperator</code></pre>
<p><strong>源码解析</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 流操作算子,抓取流中的元素生成waterMark
 * @param &lt;T&gt; The type of the input elements
 *&#x2F;
public class TimestampsAndPeriodicWatermarksOperator&lt;T&gt;
		extends AbstractUdfStreamOperator&lt;T, AssignerWithPeriodicWatermarks&lt;T&gt;&gt;
		implements OneInputStreamOperator&lt;T, T&gt;, ProcessingTimeCallback &#123;

	private static final long serialVersionUID &#x3D; 1L;

	private transient long watermarkInterval;

	private transient long currentWatermark;

	public TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks&lt;T&gt; assigner) &#123;
		super(assigner);
		this.chainingStrategy &#x3D; ChainingStrategy.ALWAYS;
	&#125;

	@Override
	public void open() throws Exception &#123;
		super.open();

		currentWatermark &#x3D; Long.MIN_VALUE;
		watermarkInterval &#x3D; getExecutionConfig().getAutoWatermarkInterval();

		if (watermarkInterval &gt; 0) &#123;
			long now &#x3D; getProcessingTimeService().getCurrentProcessingTime();
			getProcessingTimeService().registerTimer(now + watermarkInterval, this);
		&#125;
	&#125;

	@Override
	public void processElement(StreamRecord&lt;T&gt; element) throws Exception &#123;
		final long newTimestamp &#x3D; userFunction.extractTimestamp(element.getValue(),
				element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);

		output.collect(element.replace(element.getValue(), newTimestamp));
	&#125;

	@Override
	public void onProcessingTime(long timestamp) throws Exception &#123;
		&#x2F;&#x2F; register next timer
		Watermark newWatermark &#x3D; userFunction.getCurrentWatermark();
		if (newWatermark !&#x3D; null &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) &#123;
			currentWatermark &#x3D; newWatermark.getTimestamp();
			&#x2F;&#x2F; emit watermark
			output.emitWatermark(newWatermark);
		&#125;

		long now &#x3D; getProcessingTimeService().getCurrentProcessingTime();
		getProcessingTimeService().registerTimer(now + watermarkInterval, this);
	&#125;

	&#x2F;**
	 * Override the base implementation to completely ignore watermarks propagated from
	 * upstream (we rely only on the &#123;@link AssignerWithPeriodicWatermarks&#125; to emit
	 * watermarks from here).
	 *&#x2F;
	@Override
	public void processWatermark(Watermark mark) throws Exception &#123;
		&#x2F;&#x2F; if we receive a Long.MAX_VALUE watermark we forward it since it is used
		&#x2F;&#x2F; to signal the end of input and to not block watermark progress downstream
		if (mark.getTimestamp() &#x3D;&#x3D; Long.MAX_VALUE &amp;&amp; currentWatermark !&#x3D; Long.MAX_VALUE) &#123;
			currentWatermark &#x3D; Long.MAX_VALUE;
			output.emitWatermark(mark);
		&#125;
	&#125;

	@Override
	public void close() throws Exception &#123;
		super.close();

		&#x2F;&#x2F; emit a final watermark 如果新的waterMark比当前的waterMark大,就发送waterMark
		Watermark newWatermark &#x3D; userFunction.getCurrentWatermark();
		if (newWatermark !&#x3D; null &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) &#123;
			currentWatermark &#x3D; newWatermark.getTimestamp();
			&#x2F;&#x2F; emit watermark
			output.emitWatermark(newWatermark);
		&#125;
	&#125;
&#125;</code></pre>
<h2 id="6-waterMark实战分析"><a href="#6-waterMark实战分析" class="headerlink" title="6.waterMark实战分析"></a>6.waterMark实战分析</h2><p><strong>数据</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">sensor_1,1610506279,5
sensor_1,1610506280,10
sensor_1,1610506281,20
sensor_1,1610506282,30
sensor_1,1610506283,40
sensor_1,1610506284,50
sensor_1,1610506285,60
sensor_1,1610506286,70
sensor_1,1610506287,80
sensor_1,1610506290,100
sensor_1,1610506292,100</code></pre>
<p><strong>程序</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ecust.watermark;

import org.apache.flink.api.common.functions.FoldFunction;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;
import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;

import javax.annotation.Nullable;

&#x2F;**
 * @author JueQian
 * @create 01-14 15:17
 * 这个程序主要根据源码重写waterMark方法
 *&#x2F;
public class Flink07_Window_WaterMark_MyTest &#123;
    public static void main(String[] args) throws Exception &#123;
        &#x2F;&#x2F;0x0 获取执行环境
        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(1);

        &#x2F;&#x2F;0x1 设定事件时间语义
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        &#x2F;&#x2F;0x2 设置生成watermark的周期
        env.getConfig().setAutoWatermarkInterval(2000);

        &#x2F;&#x2F;0x3 获取nc数据
        DataStreamSource&lt;String&gt; socketTextStream &#x3D; env.socketTextStream(&quot;hadoop102&quot;, 9999);

        &#x2F;&#x2F;0x4 指定事件时间字段
        SingleOutputStreamOperator&lt;String&gt; watermarks &#x3D; socketTextStream.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks&lt;String&gt;() &#123;
            long currentTimeStamp &#x3D; 0L;&#x2F;&#x2F;用于存储当前元素的时间语义

            &#x2F;&#x2F;允许迟到的数据
            long maxDelayAllowed &#x3D; 2000L;
            &#x2F;&#x2F;当前水位线
            long currentWaterMark;

            private long lastEmittedWatermark &#x3D; -9223372036854775808L;

            @Nullable
            @Override
            public Watermark getCurrentWatermark() &#123;
                long potentialWM;&#x2F;&#x2F;定义判断水位线

                potentialWM &#x3D; currentTimeStamp - maxDelayAllowed;
                &#x2F;&#x2F;保证waterMark自增
                if (potentialWM &gt;&#x3D; lastEmittedWatermark) &#123;
                    lastEmittedWatermark &#x3D; potentialWM;
                &#125;
                System.out.println(&quot;当前水位线:&quot; + lastEmittedWatermark);
                return new Watermark(lastEmittedWatermark);
            &#125;

            @Override
            public long extractTimestamp(String s, long l) &#123;
                String[] fields &#x3D; s.split(&quot;,&quot;);
                long timeStamp &#x3D; Long.parseLong(fields[1])*1000L;
                &#x2F;&#x2F;取最大的作为当前时间戳
                currentTimeStamp &#x3D; Math.max(timeStamp, currentTimeStamp);
                System.out.println(&quot;key:&quot; + fields[0] + &quot;,EventTime:&quot; + timeStamp + &quot;,水位线:&quot; + currentWaterMark);
                return timeStamp;
            &#125;
        &#125;);

        &#x2F;&#x2F;0x4 转换为键值对
        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; string2One &#x3D; watermarks.map(new MapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;
            @Override
            public Tuple2&lt;String, Integer&gt; map(String s) throws Exception &#123;
                String[] fields &#x3D; s.split(&quot;,&quot;);
                return new Tuple2&lt;&gt;(fields[0],1);
            &#125;
        &#125;);

        &#x2F;&#x2F;0x5 分组开窗处理数据
        string2One.keyBy(0).timeWindow(Time.seconds(5)).sum(1).print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;输出数据&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);

        &#x2F;&#x2F;0x6 执行数据
        env.execute();
    &#125;
&#125;</code></pre>
<p><strong>Windowing</strong>：就是负责该如何生成Window，比如Fixed Window、Slide Window，当你配置好生成Window的策略时，Window就会根据时间动态生成，最终得到一个一个的Window，包含一个时间范围：[起始时间, 结束时间)，它们是一个一个受限于该时间范围的事件记录的容器，每个Window会收集一堆记录，满足指定条件会触发Window内事件记录集合的计算处理。</p>
<p><strong>WaterMark</strong>：它其实不太好理解，可以将它定义为一个函数E=f(P)，当前处理系统的处理时间P，根据一定的策略f会映射到一个事件时间E，可见E在坐标系中的表现形式是一条曲线，根据f的不同曲线形状也不同。假设，处理时间12:00:00，我希望映射到事件时间11:59:30，这时对于延迟30秒以内（事件时范围11:59:30~12:00:00）的事件记录到达处理系统，都指派到时间范围包含处理时间12:00:00这个Window中。事件时间超过12:00:00的就会由Trigger去做补偿了。</p>
<p><strong>Trigger</strong>：为了满足实际不同的业务需求，对上述事件记录指派给Window未能达到实际效果，而做出的一种补偿，比如事件记录在WaterMark时间戳之后到达事件处理系统，因为已经在对应的Window时间范围之后，我有很多选择：选择丢弃，选择是满足延迟3秒后还是指派给该Window，选择只接受对应的Window时间范围之后的5个事件记录，等等，这都是满足业务需要而制定的触发Window重新计算的策略，所以非常灵活。</p>
<h3 id="6-1-总结"><a href="#6-1-总结" class="headerlink" title="6.1 总结"></a>6.1 总结</h3><p>watermark本质是一个不断生成的在流中的时间戳</p>
<p>waterMark是真正触发缓存算子计算的时间</p>
<p>用于处理乱序数据</p>
<h2 id="7-WaterMark实战分析2"><a href="#7-WaterMark实战分析2" class="headerlink" title="7.WaterMark实战分析2"></a>7.WaterMark实战分析2</h2><p><strong>自定义数据源</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ecust.source;

import com.ecust.beans.SensorReading;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.source.SourceFunction;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

&#x2F;**
 * @author Jinxin Li
 * @create 2021-01-08 21:07
 *&#x2F;
public class Flink05_Source_UDFSource &#123;
    public static void main(String[] args) throws Exception &#123;
        &#x2F;&#x2F;0x0 创建执行环境
        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        &#x2F;&#x2F;0x1 获取执行环境
        DataStreamSource&lt;SensorReading&gt; sensorDS &#x3D; env.addSource(new MySource());

        &#x2F;&#x2F;0x2 打印环境
        SingleOutputStreamOperator&lt;String&gt; map &#x3D; sensorDS.map(new MapFunction&lt;SensorReading, String&gt;() &#123;
            @Override
            public String map(SensorReading sensorReading) throws Exception &#123;
                return sensorReading.getId() + &quot;,&quot; + sensorReading.getTs() + &quot;,&quot; + sensorReading.getTemp();
            &#125;
        &#125;);
        map.print();

        &#x2F;&#x2F;0x3 启动环境
        env.execute();
    &#125;

    &#x2F;&#x2F;0x0 定义自定义数据源
    public static class MySource implements SourceFunction&lt;SensorReading&gt;&#123;

        &#x2F;&#x2F;定义标记控制数据的运行
        private boolean running &#x3D; true;

        &#x2F;&#x2F;定义一个随机数据
        private Random random &#x3D; new Random();


        &#x2F;&#x2F;定义基准温度数组
        private Map&lt;String,SensorReading&gt; map &#x3D; new HashMap&lt;String,SensorReading&gt;();

        @Override
        public void run(SourceContext&lt;SensorReading&gt; sourceContext) throws Exception &#123;
            &#x2F;&#x2F;0x0 造数据 给传感器赋值
            for (int i &#x3D; 0; i &lt; 1; i++) &#123;
                SensorReading sensorReading &#x3D; map.put(&quot;sensor_&quot; + i, new SensorReading(&quot;sensor_&quot; + (i+1), System.currentTimeMillis()-10000000L, 60D+random.nextGaussian() * 20));
            &#125;
            while (running)&#123;
                &#x2F;&#x2F;0x1 发送数据
                for (String s : map.keySet()) &#123;
                    &#x2F;&#x2F;设定温度
                    double v &#x3D; map.get(s).getTemp() + random.nextGaussian() * 4;
                    &#x2F;&#x2F;每次温度都要增大
                    map.get(s).setTemp(v);

                    &#x2F;&#x2F;设定时间每次都要增大
                    long ts &#x3D; map.get(s).getTs() + random.nextInt(1000);
                    SensorReading sensorReading &#x3D; map.get(s);
                    sensorReading.setTs(ts);
&#x2F;&#x2F;                    System.out.println(i);
&#x2F;&#x2F;                    System.out.println(map.get(s).getTs());

                    &#x2F;&#x2F;写出数据
                    sourceContext.collect(sensorReading);

                    &#x2F;&#x2F;停顿一下
                    Thread.sleep(10);
                &#125;
            &#125;
        &#125;

        @Override
        public void cancel() &#123;
            running&#x3D;false;

        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>模拟实战数据</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ecust.watermark;

import com.ecust.beans.SensorReading;
import com.ecust.source.Flink05_Source_UDFSource;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.streaming.api.windowing.time.Time;

import javax.annotation.Nullable;

&#x2F;**
 * @author JueQian
 * @create 01-14 15:17
 * 这个程序主要根据源码重写waterMark方法
 * 在上个程序中,主要测试了watermark的生成
 * 但是使用的是端口数据
 * 端口数据发送较慢,一般一个数据后面会生成多个waterMark,不符合正常使用
 * 使用自定义数据源
 *
 * 参数:watermark间隔:2s
 * 滚动窗口:5s
 * 无序度:2s
 * 事件产生速率:0.3s
 *&#x2F;
public class Flink08_Window_WaterMark_MyTest1 &#123;
    public static void main(String[] args) throws Exception &#123;

        &#x2F;&#x2F;0x0 获取执行环境 并配置一些环境参数
        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.getConfig().setAutoWatermarkInterval(2000L);&#x2F;&#x2F;好像没用 啊,亲
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        &#x2F;&#x2F;0x1 获取自定义数据源
        DataStreamSource&lt;SensorReading&gt; sensor &#x3D; env.addSource(new Flink05_Source_UDFSource.MySource());
        SingleOutputStreamOperator&lt;SensorReading&gt; singleOutputStreamOperator &#x3D; sensor.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks&lt;SensorReading&gt;() &#123;
            &#x2F;&#x2F;当前流时间
            long currentMaxTimestamp &#x3D; 0L;
            &#x2F;&#x2F;当前流waterMark
            long lastEmittedWatermark &#x3D; -9223372036854775808L;
            &#x2F;&#x2F;当前流无序度
            long maxOutOfOrderness &#x3D; 2000L;

            @Override
            public Watermark getCurrentWatermark() &#123;
                long potentialWM &#x3D; currentMaxTimestamp - maxOutOfOrderness;
                &#x2F;&#x2F;保证自增
                if (potentialWM &gt;&#x3D; this.lastEmittedWatermark) &#123;
                    lastEmittedWatermark &#x3D; potentialWM;
                &#125;
                System.out.println(&quot;当前WaterMark为:&quot; + lastEmittedWatermark);
                return new Watermark(lastEmittedWatermark);
            &#125;

            @Override
            public long extractTimestamp(SensorReading sensorReading, long l) &#123;
                Long timestamp &#x3D; sensorReading.getTs();
                &#x2F;&#x2F;如果事件的时间比较小,则不会更新时间戳
                currentMaxTimestamp &#x3D; Math.max(currentMaxTimestamp, timestamp);
                System.out.println(&quot;key:&quot; + sensorReading.getId() + &quot;,EventTime:&quot; + timestamp + &quot;,水位线:&quot; + lastEmittedWatermark);
                return timestamp;
            &#125;
        &#125;);

        singleOutputStreamOperator.keyBy(SensorReading::getId).timeWindow(Time.seconds(5)).maxBy(&quot;temp&quot;).print(&quot;输出结果&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);

        env.execute(&quot;test&quot;);
    &#125;
&#125;</code></pre>
<p><strong>结果</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">当前WaterMark为:1610660784344
    &#x2F;&#x2F;更新水位线 结束水位线之前的时间戳的窗口 
key:sensor_1,EventTime:1610660787098,水位线:1610660784344&#x2F;&#x2F;[85000,90000]
key:sensor_1,EventTime:1610660787819,水位线:1610660784344&#x2F;&#x2F;[85000,90000]
key:sensor_1,EventTime:1610660788714,水位线:1610660784344&#x2F;&#x2F;[85000,90000]
key:sensor_1,EventTime:1610660789119,水位线:1610660784344&#x2F;&#x2F;[85000,90000]
key:sensor_1,EventTime:1610660789771,水位线:1610660784344&#x2F;&#x2F;[85000,90000]
key:sensor_1,EventTime:1610660790678,水位线:1610660784344&#x2F;&#x2F;[90000,95000]
key:sensor_1,EventTime:1610660791328,水位线:1610660784344&#x2F;&#x2F;[90000,95000]
key:sensor_1,EventTime:1610660791645,水位线:1610660784344&#x2F;&#x2F;[90000,95000]
	...
key:sensor_1,EventTime:1610660795319,水位线:1610660784344&#x2F;&#x2F;[95000,100000]
key:sensor_1,EventTime:1610660795944,水位线:1610660784344&#x2F;&#x2F;[95000,100000]
key:sensor_1,EventTime:1610660796642,水位线:1610660784344&#x2F;&#x2F;[95000,100000]
key:sensor_1,EventTime:1610660796926,水位线:1610660784344&#x2F;&#x2F;[95000,100000]
当前WaterMark为:1610660794926 &#x2F;&#x2F;[更新水位线时间是94926&gt;90000 关闭90000之前的窗口]
key:sensor_1,EventTime:1610660797035,水位线:1610660794926
key:sensor_1,EventTime:1610660797673,水位线:1610660794926
key:sensor_1,EventTime:1610660798467,水位线:1610660794926
输出&gt;&gt; SensorReading(id&#x3D;sensor_1, ts&#x3D;1610660782065, temp&#x3D;71.80984937005488)
输出&gt;&gt; SensorReading(id&#x3D;sensor_1, ts&#x3D;1610660789119, temp&#x3D;93.17010762180462)</code></pre>
<h3 id="7-1总结"><a href="#7-1总结" class="headerlink" title="7.1总结"></a>7.1总结</h3><p>问题:不知道为什么水位线不更新(200ms)</p>
<p>每200ms更新一次水位线,如果水位线更新之后时间,存在窗口没有关闭,则触发计算</p>
<p>window是一种缓存算子</p>
<pre class="mermaid">graph LR
A[window]-->B[timeWindow]
A-->C[globalWindow]</pre>

<ul>
<li>Collections.singletonList()返回的是不可变的集合，但是这个长度的集合只有1，可以减少内存空间。但是返回的值依然是Collections的内部实现类，同样没有add的方法，调用add，set方法会报错</li>
</ul>
<h1 id="0x5-WaterMark与Window的源码结构总结"><a href="#0x5-WaterMark与Window的源码结构总结" class="headerlink" title="0x5 WaterMark与Window的源码结构总结"></a>0x5 WaterMark与Window的源码结构总结</h1><h2 id="1-WaterMark与时间戳提取器源码结构"><a href="#1-WaterMark与时间戳提取器源码结构" class="headerlink" title="1.WaterMark与时间戳提取器源码结构"></a>1.WaterMark与时间戳提取器源码结构</h2><p>用于提取时间戳与waterMark</p>
<pre class="mermaid">graph TD
A[TimestampAssigner]-->B[AssignerWithPeriodicWatermarks]
A-->C[AssignerWithPunctuatedWatermarks]
B-->D[AscendingTimestampExtractor]
B-->G[BoundedOutOfOrdernessTImestamoExtractor]</pre>

<h2 id="2-数据流源码结构"><a href="#2-数据流源码结构" class="headerlink" title="2.数据流源码结构"></a>2.数据流源码结构</h2><p>数据流种类</p>
<pre class="mermaid">graph TD
A[DataStream]-->B[SingleOutputStreamOperator]
A-->C[SplitStream]
A-->D[KeyedStream]
B-->G[IterativeStream]
B-->E[DataStreamSource]</pre>

<h2 id="3-算子源码结构"><a href="#3-算子源码结构" class="headerlink" title="3.算子源码结构"></a>3.算子源码结构</h2><p>算子源码种类与结构</p>
<pre class="mermaid">graph TD
A[StreamOperator]-->B[TwoInputOperator]
A-->C[OneInputStreamOperator]
C-->D[TimestampsAndPeriodicWaterMarksOperator]
C-->F[WindowOperator]
C-->G[StreamMap]
C-->I[...]</pre>

<h2 id="4-WaterMark使用源码流程"><a href="#4-WaterMark使用源码流程" class="headerlink" title="4.WaterMark使用源码流程"></a>4.WaterMark使用源码流程</h2><p>如果获取WaterMark以及如何往下级发送</p>
<p>先提取事件事件,然后获得当前的WaterMark</p>
<pre class="mermaid">graph TD
A[提取-AssignerWithPeriodicWatermarks]-->B[extractTimestamp]-->C[getCurrentWatermark]</pre>

<p><strong>结论</strong>:所以每个record的waterMark都是上一级的waterMark,因为每次获取事件的时间戳之后都要减去无序度</p>
<p>循环发送waterMark</p>
<p><strong>执行:TimestampsAndPeriodicWatermarksOperator</strong></p>
<pre class="mermaid">graph TD
A[提取-Operator]-->B[open-定时200ms]--响应-->C[onTime-getCurrentWaterMark]
C--回调-->D[定时200ms]
D--响应-->C
C-->E{new>current}
E--emitWatermark-->F[下级算子]</pre>

<p><strong>结论</strong>:使用定时器来回调实现每隔200s进行发送,可以设置,但是只有当取生成的waterMark比现在的waterMark大才会进行往下级发送</p>
<h2 id="5-WaterMark类源码继承树结构"><a href="#5-WaterMark类源码继承树结构" class="headerlink" title="5.WaterMark类源码继承树结构"></a>5.WaterMark类源码继承树结构</h2><pre class="mermaid">graph TD
A[StreamElement]-->B[StreamRecord]
A-->C[StreamStatus]
A-->D[WaterMark]
A-->E[latencyMarker]</pre>

<p>**结论:**waterMark本质是时间戳,跟Record一样,在流中</p>
<h2 id="6-总结-使用WaterMark具体流程-抽象"><a href="#6-总结-使用WaterMark具体流程-抽象" class="headerlink" title="6.总结:使用WaterMark具体流程 抽象"></a>6.总结:使用WaterMark具体流程 抽象</h2><p>指定-提取-发送</p>
<p><img src="https://cdn.jsdelivr.net/gh/fourgold/images/fourgold/images/img_21_01/Watermark.png" alt="water抽象示意图"></p>
<h1 id="0x6-Window源码继承关系"><a href="#0x6-Window源码继承关系" class="headerlink" title="0x6 Window源码继承关系"></a>0x6 Window源码继承关系</h1><p>上面图已经讲明白,KeyedStream继承于DataStream</p>
<h2 id="1-KeyedStream的Window方法"><a href="#1-KeyedStream的Window方法" class="headerlink" title="1.KeyedStream的Window方法"></a>1.KeyedStream的Window方法</h2><pre class="mermaid">graph LR
A[KeyedStream]-->B[m-timeWindow]-->H[window/TumblingEventTimeWindows]
A-->C[m-countwindow]-->I[window/GlobalWindows.create]
A-->D[m-window]-->E[WindowedStream/this assigner]</pre>

<p>**结论:**window的方法比如<code>timewindow</code>,底层都是<code>window(windowAssigner)</code>执行的</p>
<p>而window的底层是windowStream</p>
<h2 id="2-windowAssigner的作用与源码"><a href="#2-windowAssigner的作用与源码" class="headerlink" title="2.windowAssigner的作用与源码"></a>2.windowAssigner的作用与源码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">* A &#123;@code WindowAssigner&#125; assigns zero or more &#123;@link Window Windows&#125; to an element.
*
* &lt;p&gt;In a window operation, elements are grouped by their key (if available) and by the windows to which it was assigned. The set of elements with the same key and window is called a pane.
* When a &#123;@link Trigger&#125; decides that a certain pane should fire the
* &#123;@link org.apache.flink.streaming.api.functions.windowing.WindowFunction&#125; is applied
* to produce output elements for that pane.</code></pre>
<p>主要用是分配一个或者多个窗口给新来的元素</p>
<p>一个元素的集合拥有相同的key与窗口称为窗格</p>
<p>watermark之后Trigger触发WindowFunction的计算</p>
<pre class="mermaid">graph LR
A[WindowAssigner]-->B[SildingEventTimeWIndows]
A-->C[TumbingEventTimeWIndows]
A-->D[...]</pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The window assigner. *&#x2F;
private final WindowAssigner&lt;? super T, W&gt; windowAssigner;

&#x2F;** The trigger that is used for window evaluation&#x2F;emission. *&#x2F;
private Trigger&lt;? super T, ? super W&gt; trigger;

&#x2F;** The evictor that is used for evicting elements before window evaluation. *&#x2F;
private Evictor&lt;? super T, ? super W&gt; evictor;</code></pre>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>window其实就两种类型:timeWindow与Globalwindow</p>
<p>countWindow是GlobalWindow+定制的trigger+evictor实现的</p>
<p>timeWindow这些方法底层都是<code>window(windowAssigner)</code></p>
<p>windowAssigner是各种各样的窗口类型</p>
<p>window的底层是WindowStream</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;keyedStream-&gt;countwindow 调用方法底层是window
public WindowedStream&lt;T, KEY, GlobalWindow&gt; countWindow(long size, long slide) &#123;
		return window(GlobalWindows.create())
				.evictor(CountEvictor.of(size))
				.trigger(CountTrigger.of(slide));
	&#125;

&#x2F;&#x2F;keyedStream window底层是WindowedStream
@PublicEvolving
	public &lt;W extends Window&gt; WindowedStream&lt;T, KEY, W&gt; window(WindowAssigner&lt;? super T, W&gt; assigner) &#123;
		return new WindowedStream&lt;&gt;(this, assigner);&#x2F;&#x2F;--&gt;
	&#125;

&#x2F;&#x2F;----------------------------------------------------

&#x2F;&#x2F;WindowedStream
&#x2F;*
the stream of elements is split into windows based on a &#123;windowing.assigners.WindowAssigner&#125;. 
Window emission is triggered based on a &#123;windowing.triggers.Trigger&#125;.
*&#x2F;

@PublicEvolving
	public WindowedStream(KeyedStream&lt;T, K&gt; input,
			WindowAssigner&lt;? super T, W&gt; windowAssigner) &#123;
		this.input &#x3D; input;
		this.windowAssigner &#x3D; windowAssigner;
		this.trigger &#x3D; windowAssigner.getDefaultTrigger(input.getExecutionEnvironment());
&#125;</code></pre>
<p>各种window的继承树</p>
<pre class="mermaid">graph LR
A[window]-->B[windowAssigner]-->C[各种window]</pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jinxin Li</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://fourgold.github.io/2018/09/07/Flink04_Timestamp%E4%B8%8EWindow/">http://fourgold.github.io/2018/09/07/Flink04_Timestamp%E4%B8%8EWindow/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Jinxin Li</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/04/29/Spark_Kernel/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="Spark_Kernel">
                        
                        <span class="card-title">Spark_Kernel</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-04-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/spark/" class="post-category">
                                    spark
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/spark/">
                        <span class="chip bg-color">spark</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2018/09/07/Flink04_Timestamp%E4%B8%8EWindow/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="Flink04_Timestamp与window的实战与源码分析">
                        
                        <span class="card-title">Flink04_Timestamp与window的实战与源码分析</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            里面除了基础对于WaterMark与window的解释外,还有源码架构与实战理解watermark,让你肉眼可见watermark,不过要想看懂还是得下功夫
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2018-09-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Jinxin Li
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Jinxin Li</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">56.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/fourgold" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:799392914@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=799392914" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 799392914" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
